package practica10;

import Paint2D.CellRendererFiltros;
import Paint2D.Herramientas;
import Paint2D.MiBufferedImage;
import Paint2D.MiCellRenderer;
import Paint2D.MiDialogo;
import Paint2D.MisFiltros;
import java.awt.Color;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.ByteLookupTable;
import java.awt.image.ColorModel;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.awt.image.LookupOp;
import java.awt.image.LookupTable;
import java.awt.image.RescaleOp;
import java.awt.image.WritableRaster;
import java.io.File;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.event.InternalFrameAdapter;
import javax.swing.event.InternalFrameEvent;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import sm.image.KernelProducer;
import sm.image.LookupTableProducer;

/**
 *
 * @author Francisco Beltrán Sánchez
 */
public class MarcoPrincipal extends javax.swing.JFrame {

    /**
     * Atributos de la ventana principal
     */
    private MarcoSecundario ventanaActiva;
    private ArrayList<MarcoSecundario> lienzos=new ArrayList();
    
    private MiManejador manejador=new MiManejador();
    private BufferedImage imagenAux=null;
    
    /**
     * Creates new form MarcoPrincipal
     */
   
    public MarcoPrincipal() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        barraSuperior = new javax.swing.JPanel();
        botonNuevo = new javax.swing.JButton();
        botonAbrir = new javax.swing.JButton();
        botonGuardar = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        modoPunto = new javax.swing.JToggleButton();
        modoLinea = new javax.swing.JToggleButton();
        modoRectangulo = new javax.swing.JToggleButton();
        modoElipse = new javax.swing.JToggleButton();
        jSeparator2 = new javax.swing.JSeparator();
        seleccionColores = new javax.swing.JComboBox<Color>();
        jSeparator3 = new javax.swing.JSeparator();
        selectorGrosor = new javax.swing.JSpinner();
        modoEditar = new javax.swing.JToggleButton();
        modoRelleno = new javax.swing.JToggleButton();
        modoTransparencia = new javax.swing.JToggleButton();
        modoAlisar = new javax.swing.JToggleButton();
        botonNegativo = new javax.swing.JButton();
        duplicado = new javax.swing.JButton();
        barraInferior = new javax.swing.JPanel();
        barraEstado = new javax.swing.JLabel();
        jToolBar1 = new javax.swing.JToolBar();
        panelBrillo = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        sliderBrillo = new javax.swing.JSlider();
        jSeparator4 = new javax.swing.JToolBar.Separator();
        panelFiltro = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        comboFiltro = new javax.swing.JComboBox();
        jSeparator5 = new javax.swing.JToolBar.Separator();
        panelContraste = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        botonesContraste = new javax.swing.JPanel();
        botonContraste = new javax.swing.JButton();
        botonContrasteIluminado = new javax.swing.JButton();
        botonContrasteOscurecido = new javax.swing.JButton();
        jSeparator6 = new javax.swing.JToolBar.Separator();
        panelCuadratico = new javax.swing.JPanel();
        botonCuadratica = new javax.swing.JButton();
        sliderM = new javax.swing.JSlider();
        jSeparator7 = new javax.swing.JToolBar.Separator();
        panelRotacion = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        sliderRotacion = new javax.swing.JSlider();
        rotacion90 = new javax.swing.JButton();
        rotacion180 = new javax.swing.JButton();
        rotacion270 = new javax.swing.JButton();
        jSeparator8 = new javax.swing.JToolBar.Separator();
        panelEscala = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        aumentarEscala = new javax.swing.JButton();
        disminuirEscala = new javax.swing.JButton();
        escritorio = new javax.swing.JDesktopPane();
        barraMenu = new javax.swing.JMenuBar();
        menuArchivo = new javax.swing.JMenu();
        opcionNuevo = new javax.swing.JMenuItem();
        opcionAbrir = new javax.swing.JMenuItem();
        opcionGuardar = new javax.swing.JMenuItem();
        menuImagen = new javax.swing.JMenu();
        rescaleOp = new javax.swing.JMenuItem();
        convolveOp = new javax.swing.JMenuItem();
        affineTransformOp = new javax.swing.JMenuItem();
        lookupOp = new javax.swing.JMenuItem();
        bandCombineOp = new javax.swing.JMenuItem();
        colorConvertOp = new javax.swing.JMenuItem();
        menuEdicion = new javax.swing.JMenu();
        visibilidadBarraEstado = new javax.swing.JMenuItem();
        visibilidadBarraFormas = new javax.swing.JMenuItem();
        visibilidadBarraAtributos = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        barraSuperior.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        botonNuevo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/nuevo.png"))); // NOI18N
        botonNuevo.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        botonNuevo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonNuevoActionPerformed(evt);
            }
        });
        barraSuperior.add(botonNuevo);

        botonAbrir.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/abrir.png"))); // NOI18N
        botonAbrir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonAbrirActionPerformed(evt);
            }
        });
        barraSuperior.add(botonAbrir);

        botonGuardar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/guardar.png"))); // NOI18N
        botonGuardar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonGuardarActionPerformed(evt);
            }
        });
        barraSuperior.add(botonGuardar);

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);
        jSeparator1.setPreferredSize(new java.awt.Dimension(2, 50));
        barraSuperior.add(jSeparator1);

        modoPunto.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/punto.png"))); // NOI18N
        modoPunto.setFocusable(false);
        modoPunto.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        modoPunto.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        modoPunto.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modoPuntoActionPerformed(evt);
            }
        });
        barraSuperior.add(modoPunto);

        modoLinea.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/linea.png"))); // NOI18N
        modoLinea.setFocusable(false);
        modoLinea.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        modoLinea.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        modoLinea.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modoLineaActionPerformed(evt);
            }
        });
        barraSuperior.add(modoLinea);

        modoRectangulo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/rectangulo.png"))); // NOI18N
        modoRectangulo.setFocusable(false);
        modoRectangulo.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        modoRectangulo.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        modoRectangulo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modoRectanguloActionPerformed(evt);
            }
        });
        barraSuperior.add(modoRectangulo);

        modoElipse.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/elipse.png"))); // NOI18N
        modoElipse.setFocusable(false);
        modoElipse.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        modoElipse.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        modoElipse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modoElipseActionPerformed(evt);
            }
        });
        barraSuperior.add(modoElipse);

        jSeparator2.setOrientation(javax.swing.SwingConstants.VERTICAL);
        jSeparator2.setPreferredSize(new java.awt.Dimension(2, 50));
        barraSuperior.add(jSeparator2);

        seleccionColores.setRenderer(new MiCellRenderer());
        seleccionColores.setModel(new javax.swing.DefaultComboBoxModel(new Color[] { Color.BLACK, Color.RED, Color.BLUE, Color.WHITE, Color.YELLOW, Color.GREEN }));
        seleccionColores.setPreferredSize(new java.awt.Dimension(60, 40));
        seleccionColores.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                seleccionColoresItemStateChanged(evt);
            }
        });
        barraSuperior.add(seleccionColores);

        jSeparator3.setOrientation(javax.swing.SwingConstants.VERTICAL);
        jSeparator3.setPreferredSize(new java.awt.Dimension(2, 50));
        barraSuperior.add(jSeparator3);

        selectorGrosor.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                selectorGrosorStateChanged(evt);
            }
        });
        barraSuperior.add(selectorGrosor);

        modoEditar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/seleccion.png"))); // NOI18N
        modoEditar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modoEditarActionPerformed(evt);
            }
        });
        barraSuperior.add(modoEditar);

        modoRelleno.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/rellenar.png"))); // NOI18N
        modoRelleno.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modoRellenoActionPerformed(evt);
            }
        });
        barraSuperior.add(modoRelleno);

        modoTransparencia.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/transparencia.png"))); // NOI18N
        modoTransparencia.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modoTransparenciaActionPerformed(evt);
            }
        });
        barraSuperior.add(modoTransparencia);

        modoAlisar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/alisar.png"))); // NOI18N
        modoAlisar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modoAlisarActionPerformed(evt);
            }
        });
        barraSuperior.add(modoAlisar);

        botonNegativo.setText("Negativo");
        botonNegativo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonNegativoActionPerformed(evt);
            }
        });
        barraSuperior.add(botonNegativo);

        duplicado.setText("Duplicado");
        duplicado.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                duplicadoActionPerformed(evt);
            }
        });
        barraSuperior.add(duplicado);

        getContentPane().add(barraSuperior, java.awt.BorderLayout.PAGE_START);

        barraInferior.setLayout(new java.awt.BorderLayout());

        barraEstado.setText("Hola");
        barraEstado.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        barraInferior.add(barraEstado, java.awt.BorderLayout.SOUTH);

        jToolBar1.setRollover(true);

        panelBrillo.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.LOWERED));
        panelBrillo.setLayout(new java.awt.BorderLayout());

        jLabel1.setText("Brillo");
        panelBrillo.add(jLabel1, java.awt.BorderLayout.NORTH);

        sliderBrillo.setMaximum(200);
        sliderBrillo.setMinimum(-200);
        sliderBrillo.setValue(0);
        sliderBrillo.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                sliderBrilloStateChanged(evt);
            }
        });
        sliderBrillo.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                sliderBrilloFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                sliderBrilloFocusLost(evt);
            }
        });
        panelBrillo.add(sliderBrillo, java.awt.BorderLayout.CENTER);

        jToolBar1.add(panelBrillo);
        jToolBar1.add(jSeparator4);

        panelFiltro.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.LOWERED));
        panelFiltro.setLayout(new java.awt.BorderLayout());

        jLabel2.setText("Filtro");
        panelFiltro.add(jLabel2, java.awt.BorderLayout.NORTH);

        comboFiltro.setRenderer(new CellRendererFiltros());
        comboFiltro.setModel(new javax.swing.DefaultComboBoxModel(new Integer[] { KernelProducer.TYPE_MEDIA_3x3, KernelProducer.TYPE_BINOMIAL_3x3, KernelProducer.TYPE_ENFOQUE_3x3, KernelProducer.TYPE_RELIEVE_3x3, KernelProducer.TYPE_LAPLACIANA_3x3, 6, 7}));
        comboFiltro.setPreferredSize(new java.awt.Dimension(80, 50));
        comboFiltro.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                comboFiltroItemStateChanged(evt);
            }
        });
        panelFiltro.add(comboFiltro, java.awt.BorderLayout.CENTER);

        jToolBar1.add(panelFiltro);
        jToolBar1.add(jSeparator5);

        panelContraste.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));
        panelContraste.setLayout(new java.awt.BorderLayout());

        jLabel3.setText("Contraste");
        panelContraste.add(jLabel3, java.awt.BorderLayout.PAGE_START);

        botonContraste.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/contraste.png"))); // NOI18N
        botonContraste.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonContrasteActionPerformed(evt);
            }
        });
        botonesContraste.add(botonContraste);

        botonContrasteIluminado.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/iluminar.png"))); // NOI18N
        botonContrasteIluminado.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonContrasteIluminadoActionPerformed(evt);
            }
        });
        botonesContraste.add(botonContrasteIluminado);

        botonContrasteOscurecido.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/oscurecer.png"))); // NOI18N
        botonContrasteOscurecido.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonContrasteOscurecidoActionPerformed(evt);
            }
        });
        botonesContraste.add(botonContrasteOscurecido);

        panelContraste.add(botonesContraste, java.awt.BorderLayout.CENTER);

        jToolBar1.add(panelContraste);
        jToolBar1.add(jSeparator6);

        panelCuadratico.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));

        botonCuadratica.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/cuadratica.png"))); // NOI18N
        botonCuadratica.setVerticalAlignment(javax.swing.SwingConstants.BOTTOM);
        botonCuadratica.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        botonCuadratica.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonCuadraticaActionPerformed(evt);
            }
        });
        panelCuadratico.add(botonCuadratica);

        sliderM.setMaximum(255);
        sliderM.setValue(128);
        sliderM.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                sliderMStateChanged(evt);
            }
        });
        sliderM.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                sliderMFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                sliderMFocusLost(evt);
            }
        });
        panelCuadratico.add(sliderM);

        jToolBar1.add(panelCuadratico);
        jToolBar1.add(jSeparator7);

        panelRotacion.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));
        panelRotacion.setLayout(new java.awt.BorderLayout());

        jLabel4.setText("Rotacion");
        panelRotacion.add(jLabel4, java.awt.BorderLayout.PAGE_START);

        sliderRotacion.setMaximum(360);
        sliderRotacion.setValue(0);
        sliderRotacion.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                sliderRotacionStateChanged(evt);
            }
        });
        sliderRotacion.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                sliderRotacionFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                sliderRotacionFocusLost(evt);
            }
        });
        jPanel1.add(sliderRotacion);

        rotacion90.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/rotacion90.png"))); // NOI18N
        rotacion90.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rotacion90ActionPerformed(evt);
            }
        });
        jPanel1.add(rotacion90);

        rotacion180.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/rotacion180.png"))); // NOI18N
        rotacion180.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rotacion180ActionPerformed(evt);
            }
        });
        jPanel1.add(rotacion180);

        rotacion270.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/rotacion270.png"))); // NOI18N
        rotacion270.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rotacion270ActionPerformed(evt);
            }
        });
        jPanel1.add(rotacion270);

        panelRotacion.add(jPanel1, java.awt.BorderLayout.CENTER);

        jToolBar1.add(panelRotacion);
        jToolBar1.add(jSeparator8);

        panelEscala.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));
        panelEscala.setLayout(new java.awt.BorderLayout());

        jLabel5.setText("Escala");
        panelEscala.add(jLabel5, java.awt.BorderLayout.PAGE_START);

        aumentarEscala.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/aumentar.png"))); // NOI18N
        aumentarEscala.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                aumentarEscalaActionPerformed(evt);
            }
        });
        jPanel2.add(aumentarEscala);

        disminuirEscala.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/disminuir.png"))); // NOI18N
        disminuirEscala.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                disminuirEscalaActionPerformed(evt);
            }
        });
        jPanel2.add(disminuirEscala);

        panelEscala.add(jPanel2, java.awt.BorderLayout.CENTER);

        jToolBar1.add(panelEscala);

        barraInferior.add(jToolBar1, java.awt.BorderLayout.CENTER);

        getContentPane().add(barraInferior, java.awt.BorderLayout.PAGE_END);
        getContentPane().add(escritorio, java.awt.BorderLayout.CENTER);

        menuArchivo.setText("Archivo");

        opcionNuevo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/nuevo.png"))); // NOI18N
        opcionNuevo.setText("Nuevo");
        opcionNuevo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                opcionNuevoActionPerformed(evt);
            }
        });
        menuArchivo.add(opcionNuevo);

        opcionAbrir.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/abrir.png"))); // NOI18N
        opcionAbrir.setText("Abrir");
        opcionAbrir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                opcionAbrirActionPerformed(evt);
            }
        });
        menuArchivo.add(opcionAbrir);

        opcionGuardar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/paintbasico2d/iconos/guardar.png"))); // NOI18N
        opcionGuardar.setText("Guardar");
        opcionGuardar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                opcionGuardarActionPerformed(evt);
            }
        });
        menuArchivo.add(opcionGuardar);

        menuImagen.setText("Imagen");

        rescaleOp.setText("Reescalado");
        rescaleOp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rescaleOpActionPerformed(evt);
            }
        });
        menuImagen.add(rescaleOp);

        convolveOp.setText("Convolucion");
        convolveOp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                convolveOpActionPerformed(evt);
            }
        });
        menuImagen.add(convolveOp);

        affineTransformOp.setText("AffineTransform");
        affineTransformOp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                affineTransformOpActionPerformed(evt);
            }
        });
        menuImagen.add(affineTransformOp);

        lookupOp.setText("Lookup");
        lookupOp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                lookupOpActionPerformed(evt);
            }
        });
        menuImagen.add(lookupOp);

        bandCombineOp.setText("BandCombine");
        bandCombineOp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bandCombineOpActionPerformed(evt);
            }
        });
        menuImagen.add(bandCombineOp);

        colorConvertOp.setText("ColorConvert");
        colorConvertOp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                colorConvertOpActionPerformed(evt);
            }
        });
        menuImagen.add(colorConvertOp);

        menuArchivo.add(menuImagen);

        barraMenu.add(menuArchivo);

        menuEdicion.setText("Edición");

        visibilidadBarraEstado.setText("Ver barra de estado");
        visibilidadBarraEstado.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                visibilidadBarraEstadoActionPerformed(evt);
            }
        });
        menuEdicion.add(visibilidadBarraEstado);

        visibilidadBarraFormas.setText("Ver barra de formas");
        visibilidadBarraFormas.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                visibilidadBarraFormasActionPerformed(evt);
            }
        });
        menuEdicion.add(visibilidadBarraFormas);

        visibilidadBarraAtributos.setText("Ver barra de atributos");
        visibilidadBarraAtributos.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                visibilidadBarraAtributosActionPerformed(evt);
            }
        });
        menuEdicion.add(visibilidadBarraAtributos);

        barraMenu.add(menuEdicion);

        setJMenuBar(barraMenu);

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * Se crea un nuevo MarcoSecundario, se añade a un vector donde se 
     * almacenarán todas las ventanas internas generadas y se establece el 
     * estado de los botones del MarcoPrimario respecto a las propiedades de 
     * inicio del lienzo.
     * 
     * Además, se añade al MarcoSecundario un manejador de eventos, el cual 
     * viene explicado en el lugar donde se define su clase.
     */
    private void opcionNuevoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_opcionNuevoActionPerformed
        nuevoMarcoSecundario();
    }//GEN-LAST:event_opcionNuevoActionPerformed

    private void nuevoMarcoSecundario(){
        lienzos.add(new MarcoSecundario());
        escritorio.add(lienzos.get(lienzos.size()-1));
        lienzos.get(lienzos.size()-1).setVisible(true);
        
        ventanaActiva=lienzos.get(lienzos.size()-1);
        ventanaActiva.addInternalFrameListener(manejador);
        
        cambiarEstadoHerramientas(ventanaActiva.getLienzo().getHerramienta());
        
        cambiarEstadoPropiedades(ventanaActiva.getLienzo().isEditar(),
                                 ventanaActiva.getLienzo().isAlisado(),
                                 ventanaActiva.getLienzo().isTransparencia(),
                                 ventanaActiva.getLienzo().isRelleno());

        seleccionarColor((Color)ventanaActiva.getLienzo().getColor());
        
        cambiarValorGrosor(ventanaActiva.getLienzo().getGrosor());
        
        MiBufferedImage img=new MiBufferedImage(1000,1000,BufferedImage.TYPE_INT_ARGB_PRE);
        ventanaActiva.getLienzo().setImagenFondo(img);
    }
    
    /**
     * Acciones realizadas al seleccionar en la barra de herramientas el modo
     * punto. Primero se cambia en el objeto lienzo de la ventanaActiva
     * el atributo herramienta, y después se cambia el estado de la sección de 
     * herramientas del MarcoPrincipal para que concuerde con el elemento 
     * seleccionado.
     *
     * @param evt 
     */
    private void modoPuntoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modoPuntoActionPerformed
        if(ventanaActiva!=null){
            ventanaActiva.getLienzo().setHerramienta(Herramientas.Punto);
            cambiarEstadoHerramientas(ventanaActiva.getLienzo().getHerramienta());
        } 
    }//GEN-LAST:event_modoPuntoActionPerformed

    /**
     * Acciones realizadas al seleccionar en la barra de herramientas el modo
     * línea. Primero se cambia en el objeto lienzo de la ventanaActiva
     * el atributo herramienta, y después se cambia el estado de la sección de 
     * herramientas del MarcoPrincipal para que concuerde con el elemento 
     * seleccionado.
     * 
     * @param evt 
     */
    private void modoLineaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modoLineaActionPerformed
        if(ventanaActiva!=null){
            ventanaActiva.getLienzo().setHerramienta(Herramientas.Linea);
            cambiarEstadoHerramientas(ventanaActiva.getLienzo().getHerramienta());
        }
    }//GEN-LAST:event_modoLineaActionPerformed

    /**
     * Acciones realizadas al seleccionar en la barra de herramientas el modo
     * rectángulo. Primero se cambia en el objeto lienzo de la ventanaActiva
     * el atributo herramienta, y después se cambia el estado de la sección de 
     * herramientas del MarcoPrincipal para que concuerde con el elemento 
     * seleccionado.
     * 
     * @param evt 
     */
    private void modoRectanguloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modoRectanguloActionPerformed
        if(ventanaActiva!=null){
            ventanaActiva.getLienzo().setHerramienta(Herramientas.Cuadrado);
            cambiarEstadoHerramientas(ventanaActiva.getLienzo().getHerramienta());
        }
    }//GEN-LAST:event_modoRectanguloActionPerformed

    /**
     * Acciones realizadas al seleccionar en la barra de herramientas el modo
     * elipse/óvalo. Primero se cambia en el objeto lienzo de la ventanaActiva
     * el atributo herramienta, y después se cambia el estado de la sección de 
     * herramientas del MarcoPrincipal para que concuerde con el elemento 
     * seleccionado.
     * 
     * @param evt 
     */
    private void modoElipseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modoElipseActionPerformed
        if(ventanaActiva!=null){
            ventanaActiva.getLienzo().setHerramienta(Herramientas.Ovalo);
            cambiarEstadoHerramientas(ventanaActiva.getLienzo().getHerramienta());
        }
    }//GEN-LAST:event_modoElipseActionPerformed

    /**
     * Accion realizada al seleccionar en el menu de edición la visibilidad de 
     * la barra de estado.
     * 
     * @param evt 
     */
    private void visibilidadBarraEstadoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_visibilidadBarraEstadoActionPerformed
        barraEstado.setVisible(!barraEstado.isVisible());
    }//GEN-LAST:event_visibilidadBarraEstadoActionPerformed

    /**
     * Accion realizada al seleccionar en el menu de archivo la opción abrir. No
     * se abre ningún archivo ya que no tendría sentido en el programa, solo se 
     * abre la ventana de diálogo correspondiente.
     * 
     * @param evt 
     */
    private void opcionAbrirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_opcionAbrirActionPerformed
        FileFilter filtroJPEG=new FileNameExtensionFilter("Archivos JPEG", "jpg", "jpeg");
        FileFilter filtroPNG=new FileNameExtensionFilter("PNG", "png");
        JFileChooser dlg=new JFileChooser();
        dlg.addChoosableFileFilter(filtroJPEG);
        dlg.addChoosableFileFilter(filtroPNG);
        
        int resp=dlg.showOpenDialog(this);
        if(resp==JFileChooser.APPROVE_OPTION){
            try{
                File f =dlg.getSelectedFile();
                BufferedImage img=ImageIO.read(f);
                opcionNuevoActionPerformed(evt);
                ventanaActiva.getLienzo().setImagenFondo(img);
                ventanaActiva.setName(f.getName());

            }
            catch(Exception ex){
                System.err.println("Error al leer la imagen");
                
                MiDialogo diag=new MiDialogo(this,true,"Error al leer la imagen");
                diag.setLocation((this.getWidth()/2)-diag.getWidth()/2,
                                 (this.getHeight()/2)-diag.getHeight()/2);
                diag.setVisible(true);
            }
        }
    }//GEN-LAST:event_opcionAbrirActionPerformed

    /**
     * Accion realizada al seleccionar en el menu de archivo la opción guardar. No
     * se guarda ningún archivo ya que no tendría sentido en el programa, solo se 
     * abre la ventana de diálogo correspondiente.
     * 
     * @param evt 
     */
    private void opcionGuardarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_opcionGuardarActionPerformed
        if(ventanaActiva!=null){
            BufferedImage img=ventanaActiva.getLienzo().getImagenFondo(true);
            FileFilter filtroJPEG=new FileNameExtensionFilter("JPEG/JPG", "jpg", "jpeg");
            FileFilter filtroPNG=new FileNameExtensionFilter("PNG", "png");
            
            if(img!=null){
                JFileChooser dlg=new JFileChooser();
                dlg.addChoosableFileFilter(filtroJPEG);
                dlg.addChoosableFileFilter(filtroPNG);
                int resp=dlg.showSaveDialog(this);
                
                if(resp==JFileChooser.APPROVE_OPTION){
                    try{
                        File f =dlg.getSelectedFile();
                        if(dlg.getFileFilter()==filtroPNG){
                            ImageIO.write(img,"png",f);
                        }
                        else{
                            ImageIO.write(img,"jpg",f);
                        }
                        ventanaActiva.setTitle(f.getName());
                    }
                    catch(Exception ex){
                        System.err.println("Error al guardar imagen");
                        
                        MiDialogo diag=new MiDialogo(this,true,"Error al guardar la imagen");
                        diag.setLocation((this.getWidth()/2)-diag.getWidth()/2,
                                         (this.getHeight()/2)-diag.getHeight()/2);
                        diag.setVisible(true);
                    }
                }
            }
        }
    }//GEN-LAST:event_opcionGuardarActionPerformed

    /**
     * Método para recoger el valor del selector de grosor tras realizarse un 
     * cambio sobre el; y enviarlo a la ventana interna activa en ese momento.
     * @param evt 
     */
    private void selectorGrosorStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_selectorGrosorStateChanged
        if(ventanaActiva!=null)
            ventanaActiva.getLienzo().setGrosor((int)selectorGrosor.getValue());
    }//GEN-LAST:event_selectorGrosorStateChanged

    /**
     * Método para ocultar los botones de selección de formas.
     * @param evt 
     */
    private void visibilidadBarraFormasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_visibilidadBarraFormasActionPerformed
        modoPunto.setVisible(!modoPunto.isVisible());
        modoLinea.setVisible(!modoLinea.isVisible());
        modoRectangulo.setVisible(!modoRectangulo.isVisible());
        modoElipse.setVisible(!modoElipse.isVisible());
    }//GEN-LAST:event_visibilidadBarraFormasActionPerformed

    /**
     * Método para ocultar los botones de selección de atributos.
     * @param evt 
     */
    private void visibilidadBarraAtributosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_visibilidadBarraAtributosActionPerformed
        modoEditar.setVisible(!modoEditar.isVisible());
        modoAlisar.setVisible(!modoAlisar.isVisible());
        modoRelleno.setVisible(!modoRelleno.isVisible());
        modoTransparencia.setVisible(!modoTransparencia.isVisible());
    }//GEN-LAST:event_visibilidadBarraAtributosActionPerformed

    /**
     * Método que establece al lienzo el atributo color, seleccionado en el menú
     * desplegable.
     * @param evt 
     */
    private void seleccionColoresItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_seleccionColoresItemStateChanged
        if(ventanaActiva!=null)
            ventanaActiva.getLienzo().setColor((Color)evt.getItem());
    }//GEN-LAST:event_seleccionColoresItemStateChanged

    /**
     * Método que establece las acciones a realizar cuando se actua sobre el 
     * botón correspondiente al modo editar
     * @param evt 
     */
    private void modoEditarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modoEditarActionPerformed
        if(ventanaActiva!=null){
            ventanaActiva.getLienzo().setEditar(!ventanaActiva.getLienzo().isEditar());
            if(ventanaActiva.getLienzo().isEditar())
                barraEstado.setText("Modo editar activado");
            else
                barraEstado.setText("Modo editar desactivado");
        }
    }//GEN-LAST:event_modoEditarActionPerformed

    /**
     * Método que establece las acciones a realizar cuando se actua sobre el 
     * botón correspondiente al modo relleno
     * @param evt 
     */
    private void modoRellenoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modoRellenoActionPerformed
        if(ventanaActiva!=null){
            ventanaActiva.getLienzo().setRelleno(!ventanaActiva.getLienzo().isRelleno());
            if(ventanaActiva.getLienzo().isRelleno())
                barraEstado.setText("Relleno activado");
            else
                barraEstado.setText("Relleno desactivado");
        }
    }//GEN-LAST:event_modoRellenoActionPerformed

    /**
     * Método que establece las acciones a realizar cuando se actua sobre el 
     * botón correspondiente al modo transparencia
     * @param evt 
     */
    private void modoTransparenciaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modoTransparenciaActionPerformed
        
        
        if(ventanaActiva!=null){
            ventanaActiva.getLienzo().setTransparencia(!ventanaActiva.getLienzo().isTransparencia());
            if(ventanaActiva.getLienzo().isTransparencia())
                barraEstado.setText("Modo transparencia activado");
            else
                barraEstado.setText("Modo transparencia desactivado");
        }
    }//GEN-LAST:event_modoTransparenciaActionPerformed

    /**
     * Método que establece las acciones a realizar cuando se actua sobre el 
     * botón correspondiente al modo alisar
     * @param evt 
     */
    private void modoAlisarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modoAlisarActionPerformed
        if(ventanaActiva!=null){
            ventanaActiva.getLienzo().setAlisado(!ventanaActiva.getLienzo().isAlisado());
            if(ventanaActiva.getLienzo().isAlisado())
                barraEstado.setText("Modo alisado activado");
            else
                barraEstado.setText("Modo alisado desactivado");
        }
    }//GEN-LAST:event_modoAlisarActionPerformed

    private void botonNuevoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonNuevoActionPerformed
        opcionNuevoActionPerformed(evt);
    }//GEN-LAST:event_botonNuevoActionPerformed

    private void botonAbrirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonAbrirActionPerformed
        opcionAbrirActionPerformed(evt);
    }//GEN-LAST:event_botonAbrirActionPerformed

    private void botonGuardarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonGuardarActionPerformed
        opcionGuardarActionPerformed(evt);
    }//GEN-LAST:event_botonGuardarActionPerformed
    
    /**
     * La clase RescaleOp viene determinada por un factor de escala
     * (en este caso 1), un offset (en este caso 100) y un objeto
     * RenderingHints (en este caso null ya que no lo necesitamos). 
     * Un objeto de esta clase al llamar al metodo 
     * filter(imagenFuente, imagenDestino) hace un escalado de la informacion de color de los
     * pixeles con el valor de factor de escala y sumando el offset (que podriamos
     * decir que es el brillo de la imagen). 
     */
    private void rescaleOpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rescaleOpActionPerformed
        if(ventanaActiva!=null){
            BufferedImage img=ventanaActiva.getLienzo().getImagenFondo(false);
            if(img!=null){
                try{
                    RescaleOp rop=new RescaleOp(1.0F,100.0F,null);
                    rop.filter(img, img);
                    ventanaActiva.getLienzo().repaint();
                }
                catch(Exception e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }//GEN-LAST:event_rescaleOpActionPerformed
    
    /**
    * La clase Kernel determina una matriz con unos determinados valores.
    * En este caso la matriz sera 3x3 con los valores del vector filtro.
    * Esta matriz lo que hara es aplicar a los pixeles de una zona determinadas 
    * operaciones que tendran como resultado el valor del pixel de salida.
    * Este dependera de los valores que obtengan los pixeles de alrededor
    * al aplicarse la mascara de convolucion, ademas de la aplicacion de dicha 
    * mascara al pixel a modificar.
    */
    private void convolveOpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_convolveOpActionPerformed
        if(ventanaActiva!=null){
            BufferedImage img=ventanaActiva.getLienzo().getImagenFondo(false);
            if(img!=null){
                try{
                    float filtro[]={0.1f,0.1f,0.1f,0.1f,0.2f,0.1f,0.1f,0.1f,0.1f};
                    Kernel k=new Kernel(3,3,filtro);
                    ConvolveOp cop=new ConvolveOp(k);
                    BufferedImage dest=cop.filter(img, null);
                    ventanaActiva.getLienzo().setImagenFondo(dest);
                    ventanaActiva.getLienzo().repaint();
                }
                catch(Exception e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }//GEN-LAST:event_convolveOpActionPerformed

    /**
     * Cambia el brillo de una imagen.
     * 
     * Tambien contiene el codigo para tratar imagenes con canal alpha.
     * @param evt 
     */
    private void sliderBrilloStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sliderBrilloStateChanged
        if(ventanaActiva!=null){
            int brillo=sliderBrillo.getValue();
            if(imagenAux!=null){
                try{
                    RescaleOp rop;
                    if(imagenAux.getColorModel().hasAlpha()){
                        float[] scale={1.0F,1.0F,1.0F,1.0F};
                        float[] br={brillo,brillo,brillo,0};//Ponemos el ultimo parametro a 0 para no cambiar alpha                 
                        rop=new RescaleOp(scale,br,null);
                    }
                    else{
                        float scale=1.0F;
                        float br=brillo;
                        rop=new RescaleOp(scale,br,null);
                    }
                    rop.filter(imagenAux, ventanaActiva.getLienzo().getImagenFondo(false));
                    ventanaActiva.getLienzo().repaint();
                }
                catch(Exception e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }//GEN-LAST:event_sliderBrilloStateChanged

    /**
     * En esta funcion al ganar el foco el slider tenemos que crear una copia de 
     * la imagen, para poder interactuar sobre ella y no sobre la imagen generada,
     * ya que si no el brillo no se aplicaria correctamente.
     * @param evt 
     */
    private void sliderBrilloFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_sliderBrilloFocusGained
        copiaImagen();
    }//GEN-LAST:event_sliderBrilloFocusGained

    /**
     * Cuando eliminamos el foco del slider, eliminamos el valor de imagenAux, lo
     * que nos servira indirectamente para guardar el estado del brillo de una 
     * imagen. Tambien establecemos el valor del slider a 0 para que, al volver a 
     * cambiar el brillo en un momento posterior, no tengamos la barra en un valor
     * no nulo.
     * @param evt 
     */
    private void sliderBrilloFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_sliderBrilloFocusLost
        imagenAux=null;
        sliderBrillo.setValue(0);
    }//GEN-LAST:event_sliderBrilloFocusLost

    private void comboFiltroItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_comboFiltroItemStateChanged
        Kernel k;
        
        if((int)comboFiltro.getSelectedItem()<6)
            k=KernelProducer.createKernel((int)comboFiltro.getSelectedItem());
        else if((int)comboFiltro.getSelectedItem()==6){
            k=MisFiltros.createMedia5x5();
        }
        else{
            k=MisFiltros.createMedia7x7();
        }
        
        if(ventanaActiva!=null){
            BufferedImage img=ventanaActiva.getLienzo().getImagenFondo(false);
            if(img!=null){
                try{
                    ConvolveOp cop=new ConvolveOp(k,ConvolveOp.EDGE_NO_OP,null);
                    BufferedImage dest=cop.filter(img, null);
                    ventanaActiva.getLienzo().setImagenFondo(dest);
                    ventanaActiva.getLienzo().repaint();
                }
                catch(Exception e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }//GEN-LAST:event_comboFiltroItemStateChanged

    /**
     * Con la clase AffineTransform y AffineTransformOp haremos el escalado de una
     * imagen. AffineTransform representa una transformacion afin, la cual se puede
     * construir de dos maneras:
     * - Pasando la matriz de transformacion como argumento del constructor.
     * - Mediante metodos estaticos, como es el caso, en el cual escalamos el objeto
     * 1.5 veces su tamaño.
     * 
     * Al llamar al metodo filter con null tenemos que, de manera explicita, 
     * actualizar la imagen del lienzo.
     * 
     * El objeto AffineTransformOp es el encargado de aplicar una transformacion
     * a una imagen. Se crea con un objeto AffineTransform que contenga las 
     * caracteristicas que queramos transformar, y un metodo de interpolacion, 
     * que en este caso es null. En este caso, el metodo de interpolacion usado
     * sera el del vecino mas cercano (que al realizar la transformacion deja la 
     * imagen pixelada). En cambio, si usasemos un metodo de transformacion 
     * bilineal (definido como atributo estatico), al escalar la imagen se veria 
     * mas suavizada. El metodo de interpolacion, por tanto, calcula el valor de
     * los nuevos pixeles generados debido al escalado.
     * @param evt 
     */
    private void affineTransformOpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_affineTransformOpActionPerformed
        cambioTamaño(1.5);
    }//GEN-LAST:event_affineTransformOpActionPerformed

    private void cambioTamaño(double factor){
        if(ventanaActiva!=null){
            BufferedImage img=ventanaActiva.getLienzo().getImagenFondo(false);
            if(img!=null){
                try{
                    AffineTransform at=AffineTransform.getScaleInstance(factor, factor);
                    AffineTransformOp atop=new AffineTransformOp(at,AffineTransformOp.TYPE_BILINEAR);
                    BufferedImage dest=atop.filter(img,null);
                    ventanaActiva.getLienzo().setImagenFondo(dest);
                    ventanaActiva.repaint();
                }
                catch(IllegalArgumentException e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }
    
    private void bandCombineOpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bandCombineOpActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_bandCombineOpActionPerformed
    
    /**
     * La clase Lookup representa una transformacion aplicada a cada componente
     * de un pixel. En este caso, funcionT representaria esa transformacion, donde
     * dado un valor x se le asigna un valor de la tabla de transformacion 
     * correspondiente. 
     * 
     * En este ejemplo, restamos el valor de x a 255, lo que significaria que 
     * los componentes con un bajo valor pasarian a tener un alto valor y 
     * viceversa. Esto explica que al aplicar este filtro en la foto de la 
     * alhambra, el cielo que esta totalmente negro pase a estar blanco, ya que 
     * esos pixeles pasan de un valor alrededor de [0,0,0] a [255,255,255].
     * 
     * Al construir el objeto LookupOp, el segundo parametro que en este caso es
     * null corresponde a un objeto RenderingHints (para aplicar un algoritmo 
     * de renderizado a la hora de visualizar la imagen).
     * @param evt 
     */
    private void lookupOpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_lookupOpActionPerformed
        negativo();
    }//GEN-LAST:event_lookupOpActionPerformed

    private void colorConvertOpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_colorConvertOpActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_colorConvertOpActionPerformed

    /**
     * Debido al bug no documentado, el segundo parametro del metodo filter no
     * es null para asegurar que no se intercambian los canales B y R. Ademas
     * usaremos en los 3 siguientes metodos funciones ya definidas para aplicar 
     * el filtro deseado. En este primer caso, aplicamos una funcion-S. Esta 
     * funcion depende de m (refiriendonos a la formula de las transparencias)
     * ya que cuando x=m el valor resultante es el valor medio entre 0 y 255.
     */
    private void botonContrasteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonContrasteActionPerformed
        contraste(LookupTableProducer.TYPE_SFUNCION);
    }//GEN-LAST:event_botonContrasteActionPerformed

    /**
     * En este caso, aplicamos una funcion logaritmica, la cual sigue una curva
     * que nos da resultados para cada x mayores que si usasemos
     * una funcion lineal. Esta funcion aumentaria mucho el brillo, pero tenemos 
     * otras opciones como aplicar una correccion gamma, siendo el valor de esta
     * mayor que 1, o usar una funcion raiz que tiene una curva menos pronunciada.
     * @param evt 
     */
    private void botonContrasteIluminadoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonContrasteIluminadoActionPerformed
        contraste(LookupTableProducer.TYPE_LOGARITHM);
    }//GEN-LAST:event_botonContrasteIluminadoActionPerformed

    /**
     * En este caso aplicamos una funcion potencial, con la cual si observamos
     * su curva, los valores obtenidos para cada x son menores que si usasemos
     * una funcion lineal, por tanto para imagenes con mucho brillo conseguimos 
     * un oscurecimiento de la misma. Otra opcion seria usar una correccion gamma,
     * siendo esta un valor entre 0 y 1.
     * @param evt 
     */
    private void botonContrasteOscurecidoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonContrasteOscurecidoActionPerformed
        contraste(LookupTableProducer.TYPE_POWER);
    }//GEN-LAST:event_botonContrasteOscurecidoActionPerformed

    private void contraste(int tipo){
        if(ventanaActiva!=null){
            BufferedImage img=ventanaActiva.getLienzo().getImagenFondo(false);
            if(img!=null){
                try{
                    LookupTable lt=LookupTableProducer.createLookupTable(tipo);
                    LookupOp lop=new LookupOp(lt,null);
                    lop.filter(img,img);
                    ventanaActiva.repaint();
                }
                catch(IllegalArgumentException e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }
    
    private void botonCuadraticaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonCuadraticaActionPerformed
        aplicarCuadratica(128.0);
    }//GEN-LAST:event_botonCuadraticaActionPerformed

    private void aplicarCuadratica(double m){
        if(ventanaActiva!=null){
            if(imagenAux!=null){
                try{
                    LookupTable lt=cuadratica(m);
                    LookupOp lop=new LookupOp(lt,null);
                    BufferedImage dest=lop.filter(imagenAux,null);
                    ventanaActiva.getLienzo().setImagenFondo(dest);
                    ventanaActiva.repaint();
                }
                catch(IllegalArgumentException e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }
    
    /**
     * Se usan los mismos objetos que con el escalado por lo que el procedimiento
     * y el uso que recibe cada objeto es similar, pero existen dos diferencias
     * en este metodo:
     * 
     * - Tenemos que establecer el punto central de la imagen para realizar la 
     * rotacion, y asi, conseguir que la imagen no se desplace al realizar la 
     * operacion
     * 
     * - Para realizar la rotacion libre tenemos que hacerla sobre la imagen 
     * original, por tanto emplearemos la misma forma de actuar con el slider
     * de brillo. Es decir, cuando este elemento gane el foco, cargaremos la 
     * imagen original y todas las rotaciones que realicemos se haran sobre ella.
     * Asi conseguiremos rotar la imagen con el valor deseado, y que no se 
     * acumulen las rotaciones.
     * @param evt 
     */
    private void sliderRotacionStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sliderRotacionStateChanged
        rotacion(sliderRotacion.getValue(), true);
    }//GEN-LAST:event_sliderRotacionStateChanged

    private void rotacion(int grados, boolean libre){
        if(ventanaActiva!=null){
            if(imagenAux!=null || !libre){
                try{
                    double r=Math.toRadians(grados);
                    Point centro=new Point(imagenAux.getWidth()/2,imagenAux.getHeight()/2);
                    AffineTransform at=AffineTransform.getRotateInstance(r, centro.x, centro.y);
                    AffineTransformOp atop=new AffineTransformOp(at,AffineTransformOp.TYPE_BILINEAR);
                    BufferedImage dest=atop.filter(imagenAux, null);
                    ventanaActiva.getLienzo().setImagenFondo(dest);
                    ventanaActiva.repaint();
                }
                catch(IllegalArgumentException e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }
    
    private void rotacion90ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rotacion90ActionPerformed
        copiaImagen();
        rotacion(90, false);
        imagenAux=null;
    }//GEN-LAST:event_rotacion90ActionPerformed

    private void rotacion180ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rotacion180ActionPerformed
        copiaImagen();
        rotacion(180, false);
        imagenAux=null;
    }//GEN-LAST:event_rotacion180ActionPerformed

    private void rotacion270ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rotacion270ActionPerformed
        copiaImagen();
        rotacion(270, false);
        imagenAux=null;
    }//GEN-LAST:event_rotacion270ActionPerformed

    private void sliderRotacionFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_sliderRotacionFocusGained
        copiaImagen();
    }//GEN-LAST:event_sliderRotacionFocusGained
    
    private void copiaImagen(){
        if(ventanaActiva!=null){
            ColorModel cm=ventanaActiva.getLienzo().getImagenFondo(false).getColorModel();
            WritableRaster raster=ventanaActiva.getLienzo().getImagenFondo(false).copyData(null);
            boolean alfaPre=ventanaActiva.getLienzo().getImagenFondo(false).isAlphaPremultiplied();
            imagenAux=new BufferedImage(cm,raster,alfaPre,null);
        }
    }
    
    private void sliderRotacionFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_sliderRotacionFocusLost
        imagenAux=null;
        sliderRotacion.setValue(0);
    }//GEN-LAST:event_sliderRotacionFocusLost
    
    private void aumentarEscalaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aumentarEscalaActionPerformed
        cambioTamaño(1.25);
    }//GEN-LAST:event_aumentarEscalaActionPerformed

    private void disminuirEscalaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_disminuirEscalaActionPerformed
        cambioTamaño(0.75);
    }//GEN-LAST:event_disminuirEscalaActionPerformed

    private void botonNegativoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonNegativoActionPerformed
        negativo();
    }//GEN-LAST:event_botonNegativoActionPerformed

    private void duplicadoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_duplicadoActionPerformed
        if(ventanaActiva!=null){
            imagenAux=ventanaActiva.getLienzo().getImagenFondo(true);
            if(imagenAux!=null){
                nuevoMarcoSecundario();
                //A partir de aqui la ventana nueva seria la ventanaActiva
                ventanaActiva.getLienzo().setImagenFondo(imagenAux);
                imagenAux=null;
            }
        }
    }//GEN-LAST:event_duplicadoActionPerformed

    private void sliderMFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_sliderMFocusGained
        copiaImagen();
    }//GEN-LAST:event_sliderMFocusGained

    private void sliderMFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_sliderMFocusLost
        imagenAux=null;
        sliderM.setValue(128);
    }//GEN-LAST:event_sliderMFocusLost

    private void sliderMStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sliderMStateChanged
        aplicarCuadratica(sliderM.getValue());
    }//GEN-LAST:event_sliderMStateChanged
    
    /**
     * Genera un objeto LookupTable que representa una transformacion aplicando
     * una funcion cuadratica. Tenemos que definir una variable K que represente
     * el valor maximo de la funcion entre 0 y 255, para que al aplicar la 
     * funcion no obtengamos valores que salgan de esos limites. Este maximo
     * se calcula dividiendo 255 entre el valor maximo de la funcion, que sera
     * cuando i=0 si m>=128 o i=255 en caso contrario
     * 
     * En la funcion tenemos dos valores a destacar:
     * 
     * - M, que determina en que valor de i el resultado de aplicar la funcion
     * es 0
     * 
     * - 1/100 (en este caso) que hace que nuestra funcion sea mas o menos 
     * pronunciada. Es decir, si tenemos un valor mayor de esta division, 
     * las diferencias entre un indice y otro de la tabla seran mayores. 
     * @param m
     * @return LookupTable de una funcion de transformacion cuadratica.
     */
    private LookupTable cuadratica(double m){
        double K;
        if(m>=128)
            K=255.0/((1.0/100.0)*Math.pow(0-m,2)); //Cte de normalizacion
        else
            K=255.0/((1.0/100.0)*Math.pow(255-m,2));
        
        byte funcionT[]=new byte[256];
        
        for(int i=0; i<256; i++){
            funcionT[i]=(byte)(K*((1.0/100.0)*Math.pow((i-m),2)));
        }
        
        LookupTable tabla=new ByteLookupTable(0,funcionT);
        
        return tabla;
    }
    
    private void negativo(){
        if(ventanaActiva!=null){
            BufferedImage img=ventanaActiva.getLienzo().getImagenFondo(false);
            if(img!=null){
                try{
                    byte funcionT[]=new byte[256];
                    for(int x=0; x<256; x++){
                        funcionT[x]=(byte)(255-x);
                    }
                    LookupTable tabla=new ByteLookupTable(0,funcionT);
                    LookupOp lop=new LookupOp(tabla,null);
                    lop.filter(img,img);
                    ventanaActiva.repaint();
                }
                catch(IllegalArgumentException e){
                    System.err.println(e.getLocalizedMessage());
                }
            }
        }
    }
    
    /**
     * Clase manejadora de eventos del lienzo en MarcoPrincipal. Con este 
     * manejador, controlaremos cual es la ventana interna activa en cada 
     * momento de la ejecución, estableciendo los cambios necesarios cuando la
     * ventana interna activada pase a ser otra distinta.
     */
    public class MiManejador extends InternalFrameAdapter{
        
        @Override
        public void internalFrameActivated(InternalFrameEvent evt){
            ventanaActiva=(MarcoSecundario)evt.getInternalFrame();
            
            cambiarEstadoHerramientas(ventanaActiva.getLienzo().getHerramienta());
            
            cambiarEstadoPropiedades(ventanaActiva.getLienzo().isEditar(),
                                     ventanaActiva.getLienzo().isAlisado(),
                                     ventanaActiva.getLienzo().isTransparencia(),
                                     ventanaActiva.getLienzo().isRelleno());
            
            seleccionarColor((Color)ventanaActiva.getLienzo().getColor());
            
            cambiarValorGrosor(ventanaActiva.getLienzo().getGrosor());
        }
    }
    
    /**
     * Método para cambiar el estado de los botones correspondientes a
     * una herramienta. Además, mostrará un mensaje en la barra de estado 
     * notificando dicho cambio.
     * @param h. Herramienta la cual queremos que su botón correspondiente sea
     * seleccionado.
     */
    
    public void cambiarEstadoHerramientas(Herramientas h){
        switch(h){
            case Punto:
                modoLinea.setSelected(false);
                modoRectangulo.setSelected(false);
                modoElipse.setSelected(false);
                modoPunto.setSelected(true);

                barraEstado.setText("Modo punto");
            break;

            case Linea:

                modoPunto.setSelected(false);
                modoRectangulo.setSelected(false);
                modoElipse.setSelected(false);
                modoLinea.setSelected(true);

                barraEstado.setText("Modo línea");

            break;

            case Cuadrado:

                modoPunto.setSelected(false);
                modoLinea.setSelected(false);
                modoElipse.setSelected(false);
                modoRectangulo.setSelected(true);

                barraEstado.setText("Modo rectángulo");

            break;

            case Ovalo:
                modoPunto.setSelected(false);
                modoLinea.setSelected(false);
                modoRectangulo.setSelected(false);
                modoElipse.setSelected(true);

                barraEstado.setText("Modo elipse");
            break;
        }
    }
    
    /**
     * Método para establecer el estado de los botones correspondientes a las 
     * propiedades de las figuras dibujadas en un lienzo.
     * @param e. Modo Editar activado/desactivado.
     * @param a. Modo Alisar activado/desactivado.
     * @param t. Modo Transparencia activado/desactivado.
     * @param r. Modo Relleno activado/desactivado. 
     */
    public void cambiarEstadoPropiedades(boolean e, boolean a, boolean t, boolean r){
        modoRelleno.setSelected(r);
        modoAlisar.setSelected(a);
        modoTransparencia.setSelected(t);
        modoEditar.setSelected(e);
        
    }

    /**
     * Método para establecer, dentro del combobox de selección de color, una de
     * las opciones dentro de esta.
     * @param c. Color a seleccionar en la lista de colores.
     */
    public void seleccionarColor(Color c){
        seleccionColores.setSelectedItem((Color)c);
    }
    
    /**
     * Método para establecer en el selector de grosor, un valor i enviado como
     * parámetro.
     * @param i. Valor de grosor a establecer.
     */
    public void cambiarValorGrosor(int i){
        selectorGrosor.setValue(i);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem affineTransformOp;
    private javax.swing.JButton aumentarEscala;
    private javax.swing.JMenuItem bandCombineOp;
    private javax.swing.JLabel barraEstado;
    private javax.swing.JPanel barraInferior;
    private javax.swing.JMenuBar barraMenu;
    private javax.swing.JPanel barraSuperior;
    private javax.swing.JButton botonAbrir;
    private javax.swing.JButton botonContraste;
    private javax.swing.JButton botonContrasteIluminado;
    private javax.swing.JButton botonContrasteOscurecido;
    private javax.swing.JButton botonCuadratica;
    private javax.swing.JButton botonGuardar;
    private javax.swing.JButton botonNegativo;
    private javax.swing.JButton botonNuevo;
    private javax.swing.JPanel botonesContraste;
    private javax.swing.JMenuItem colorConvertOp;
    private javax.swing.JComboBox comboFiltro;
    private javax.swing.JMenuItem convolveOp;
    private javax.swing.JButton disminuirEscala;
    private javax.swing.JButton duplicado;
    private javax.swing.JDesktopPane escritorio;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JToolBar.Separator jSeparator4;
    private javax.swing.JToolBar.Separator jSeparator5;
    private javax.swing.JToolBar.Separator jSeparator6;
    private javax.swing.JToolBar.Separator jSeparator7;
    private javax.swing.JToolBar.Separator jSeparator8;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JMenuItem lookupOp;
    private javax.swing.JMenu menuArchivo;
    private javax.swing.JMenu menuEdicion;
    private javax.swing.JMenu menuImagen;
    private javax.swing.JToggleButton modoAlisar;
    private javax.swing.JToggleButton modoEditar;
    private javax.swing.JToggleButton modoElipse;
    private javax.swing.JToggleButton modoLinea;
    private javax.swing.JToggleButton modoPunto;
    private javax.swing.JToggleButton modoRectangulo;
    private javax.swing.JToggleButton modoRelleno;
    private javax.swing.JToggleButton modoTransparencia;
    private javax.swing.JMenuItem opcionAbrir;
    private javax.swing.JMenuItem opcionGuardar;
    private javax.swing.JMenuItem opcionNuevo;
    private javax.swing.JPanel panelBrillo;
    private javax.swing.JPanel panelContraste;
    private javax.swing.JPanel panelCuadratico;
    private javax.swing.JPanel panelEscala;
    private javax.swing.JPanel panelFiltro;
    private javax.swing.JPanel panelRotacion;
    private javax.swing.JMenuItem rescaleOp;
    private javax.swing.JButton rotacion180;
    private javax.swing.JButton rotacion270;
    private javax.swing.JButton rotacion90;
    private javax.swing.JComboBox<Color> seleccionColores;
    private javax.swing.JSpinner selectorGrosor;
    private javax.swing.JSlider sliderBrillo;
    private javax.swing.JSlider sliderM;
    private javax.swing.JSlider sliderRotacion;
    private javax.swing.JMenuItem visibilidadBarraAtributos;
    private javax.swing.JMenuItem visibilidadBarraEstado;
    private javax.swing.JMenuItem visibilidadBarraFormas;
    // End of variables declaration//GEN-END:variables
}
